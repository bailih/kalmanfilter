""" Battery OCV-SoC Polynomial Generator
    
    This program reads 2 data files generated by the C8000. It cuts
    out the voltage readings and finds the best fit average polynomial 
    of the 0.05C charge and discharge.
"""

import copy
import csv
import sys
import re

patt = re.compile("[^\t]+")

import matplotlib.pyplot as plt
import numpy as np

from classes import SoCTracker, LogParser

ocv = []
v_discharge = []

SAMPLE_TIME = 3.0

CELL_CAPACITY = 22000 # mAh
INIT_SOC      = 0.03
CELL_COUNT    = 14

BALANCE_CURRENT = 2000 # mA

UPPER_MILLI = 60000 # mV
LOWER_MILLI = 50000 # mV
MILLI_DIFF_TOLERANCE = 1  # mV

charging_current = 9000
charge_file_name = 'note1_90.txt'
discharge_file_name = None

j_x = None
j_y = None

# Cheating method! Takes the derivative of a polynomial, adds missing points, return new polynomial
def extrapolate_curve(poly, x, y, range_to_fit):

    if len(x) != len(y):
        raise Exception('Number of x and y values do not match')

    min_x = x[0]
    max_x = x[-1]

    new_x = copy.copy(x)
    new_y = copy.copy(y)

    # We get access to the tangent line at the minimum point. We add points on that line to fill to the lower range.
    if min_x > range_to_fit[0]:
        tangent_function = get_tangent_function(poly, x[200], y[200])

        additional_x = np.linspace(range_to_fit[0], min_x, num=100)

        for i in range(len(additional_x) - 1, 0, -1):
            new_x.insert(0, additional_x[i])
            new_y.insert(0, tangent_function(additional_x[i]))

    # We do the same with the maximum point
    if max_x < range_to_fit[1]:
        tangent_function = get_tangent_function(poly, x[-601], y[-601])

        additional_x = np.linspace(max_x, range_to_fit[1], num=100)

        for i in range(len(additional_x)):
            new_x.append(additional_x[i])
            new_y.append(tangent_function(additional_x[i]))

    #Debug only, REMOVE
    if len(new_x) != len(new_y):
        raise Exception("The person who programmed this is a dumb stupid loser. new x and new y aren't equal in length")

    global j_x
    global j_y
    j_x = new_x
    j_y = new_y
    return np.polyfit(new_x, new_y, len(poly) - 1)



# returns a function that calculates a y from an x, based on the derivative of the polynomial passed in
def get_tangent_function(poly, x, y):

    slope = 0
    for i in range(len(poly) - 1, 0, -1):
        slope += i * poly[len(poly) - 1 - i] * np.power(x, i - 1)

    offset = y - slope * x

    def derivative(x) : return slope * x + offset
    return derivative


def sorted_list_to_bst_list(list, bst_list, index=1):
    if not list:
        return
    # parent
    parent_index = (len(list) - 1) // 2
    bst_list[index] = list[parent_index]
    # left child
    sorted_list_to_bst_list(list[:parent_index], bst_list, index * 2)
    # right child
    sorted_list_to_bst_list(list[parent_index + 1:], bst_list, index * 2 + 1)

arguments = {}
i = 1
while i < len(sys.argv):
    if i + 1 < len(sys.argv) and '-' not in sys.argv[i + 1]:
        arguments[sys.argv[i]] = sys.argv[i + 1]
        i += 2
    else:
        arguments[sys.argv[i]] = True
        i += 1

if '-mc' in arguments:
    charging_current = int(arguments['-mc'])

if '-c' in arguments:
    charge_file_name = arguments['-c']

if '-d' in arguments:
    discharge_file_name = arguments['-d']




ocv_avg_soc_poly, p_d = np.zeros((1, 11)), np.zeros((1, 11))
n = 0

voltage_points = []


if charge_file_name:

    # log_parser = LogParser(MILLI_DIFF_TOLERANCE)
    # log_parser.parse(charge_file_name,
    #                  charging_current,
    #                  SAMPLE_TIME,
    #                  arguments['-f'] if '-f' in arguments else None)
    #
    #
    # soc_tracker = SoCTracker(CELL_COUNT, CELL_CAPACITY, INIT_SOC, BALANCE_CURRENT)
    # for i in range(log_parser.len):
    #     blocks = i // (log_parser.len // 50)
    #
    #     sys.stdout.write('\r[' + ('#' * blocks) + (' ' * (50 - blocks)) + ']')
    #
    #     soc_tracker.update(*log_parser.get_info(i))
    # with open(charge_file_name, 'r') as f:
    #     flines = [line.rstrip() for line in f]  # use rstrip to remove newlines
    f = open(charge_file_name, 'r')
    flines = f.read()

    fileOut = open(charge_file_name, 'w')
    f.close()

    flines.pop(0)  # first line is not data
    voltage = []
    current = []
    balance_info = []
    balance_info.append((None, None))
    for lines in flines:
        temp = patt.findall(lines)
        voltage.append(float(temp[8]) / 1000)
        current.append(float(temp[9]) / 1000)


    soc_tracker = SoCTracker(CELL_COUNT, CELL_CAPACITY, INIT_SOC, BALANCE_CURRENT)
    # for i in range(log_parser.len):
    #     blocks = i // (log_parser.len // 50)
    #
    #     sys.stdout.write('\r[' + ('#' * blocks) + (' ' * (50 - blocks)) + ']')
    #
    #     soc_tracker.update(*log_parser.get_info(i))
    for i in range(flines.len):
        blocks = i // (flines.len // 50)

        sys.stdout.write('\r[' + ('#' * blocks) + (' ' * (50 - blocks)) + ']')

        soc_tracker.update(voltage[i], current[i], SAMPLE_TIME, balance_info)

    print('')

    # If v_charge is empty, the minimum current is likely too low.
    ocv = soc_tracker.volts
    if not ocv:
        print("\n Whoops! Couldn't find any points; Is your minimum current too high?\n",
              "Currently: {}\t Use -mc to change.".format(charging_current))

        sys.exit(1)

    voltage_points = ocv


    avg_soc = soc_tracker.avg_soc
    min_soc = soc_tracker.min_soc

    ocv_avg_soc_poly = np.polyfit(avg_soc, ocv, 14)
    ocv_min_soc_poly = np.polyfit(min_soc, ocv, 14)

    ocv_soc_cheat = extrapolate_curve(ocv_avg_soc_poly, avg_soc, ocv, (0, 1)) if '-e' in arguments else None


if discharge_file_name:
    with open('Discharge.txt', 'r') as Dfile:
        rd = csv.reader(Dfile, delimiter=',')
        next(rd, None) # Skip header
        for line in rd:
            v_discharge.append(float(line[16])/1000)
        
    # Get t_charge and t_discharge
    t_discharge = np.linspace(0, 1, num=len(v_discharge))

    # Reverse direction of discharge
    v_discharge.reverse()

    # Find polynomial fit of each curve
    p_d = np.polyfit(t_discharge, v_discharge, 10)
else:
    p_d = ocv_avg_soc_poly

# Take the average polynomial fit
p_a = (ocv_avg_soc_poly + p_d) / 2
print(p_a)

if '-e' in arguments:
    with open('cheat_coefficients.txt', 'w') as f:
        for coefficient in ocv_soc_cheat:
            f.write('{},\n'.format(coefficient / 1000))
        if '-l' in arguments:
            f.write('\n\n')

            slope = (ocv[1] - 50400) / (soc_tracker.avg_soc[0])
            offset = ocv[0] - slope * soc_tracker.avg_soc[0]

            soc_increment = soc_tracker.avg_soc[0] / 500

            add_on_soc = []
            add_on_volts = []
            for i in range(500):
                add_on_soc.append(i * soc_increment)
                add_on_volts.append(i * soc_increment * slope + offset)
            soc = add_on_soc + soc_tracker.avg_soc
            volts = add_on_volts + ocv

            soc_ocv_pairs = []
            for i in range(len(soc)):
                soc_ocv_pairs.append((soc[i], volts[i]))

            bst_list = [(None, None) for _ in range(len(soc_ocv_pairs * 2))]
            sorted_list_to_bst_list(soc_ocv_pairs, bst_list)
            while(bst_list[-1] == (None, None)):
                bst_list.pop()
            for soc_ocv_pair in bst_list:
                f.write('{} {}\n'.format(*soc_ocv_pair))


# Plot

t = np.linspace(INIT_SOC, soc_tracker.avg_soc[len(soc_tracker.avg_soc) - 1], num=1000)
fit_t = np.linspace(0, 1, num=1000)

if '-e' in arguments:
    plt.plot(fit_t, np.polyval(ocv_soc_cheat, fit_t), 'y-')
    plt.plot(j_x, j_y, 'y.', ms=1.5)

plt.plot(soc_tracker.avg_soc, voltage_points, 'g.', ms=1)
plt.plot(t, np.polyval(ocv_avg_soc_poly, t), 'b-')
plt.plot(t, np.polyval(ocv_min_soc_poly, t), 'r-')



plt.show()